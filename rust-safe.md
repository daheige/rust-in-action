# Rust safety
- 安全性是Rust的显著特征之一，其安全特性使其与其他语言形成最显著差异。得益于名为借用检查器的功能，Rust能够提供强大的安全保障。
- 在C和C++等语言中，内存管理是半手动过程，开发者在考虑内存管理时必须了解实现细节。而Java、Go和Python等语言采用自动内存管理（即垃圾回收机制），以牺牲部分性能为代价，掩盖了内存分配与管理的细节。 
- Rust的借用检查器通过在编译时验证引用来运作，而非运行时进行引用计数或垃圾回收。这一独特特性在编写软件时也会带来挑战，特别是对初次接触借用检查器的开发者而言。
- 借用检查器作为Rust编译器rustc的组成部分，会确保任何给定对象或变量在同一时间内最多只能存在一个可变引用。虽然允许对对象或变量存在多个不可变引用（即只读引用），但任何时候都只能存在一个活跃的可变引用。Rust通过检查可变引用与不可变引用永远不会重叠，从而保证内存安全。
- Rust采用资源获取即初始化（RAII）机制来追踪变量及其所有引用的作用域范围。一旦超出作用域，内存即可被释放。借用检查器会阻止对已超出作用域变量的引用，并且只允许存在一个可变引用或多个不可变引用，但绝不允许两者同时存在。 
- 同时，借用检查器同样为并发编程提供了安全保障。当共享数据时（例如在不同线程之间），可能会出现竞态条件。在大多数情况下，根本原因都是相同的：同时存在多个可变共享引用。然而，Rust通过"唯一可变引用&mut T"或"一个及以上不可变引用&T"的规则，从根本上杜绝了多个可变引用并存的可能性，从而确保避免数据同步问题，或至少不会无意中引发这类问题。 
- Rust的借用检查器初学时较难掌握，但很快你就会发现这是Rust最出色的特性。与Haskell等语言类似，只要代码能通过编译（再配合充分测试），通常就能保证代码正常运行且永不崩溃。虽然有时候存在例外情况，但总体而言，用Rust编写的代码不会因常见内存错误（如缓冲区越界读取、内存分配与释放处理不当）而崩溃。
